#!/usr/bin/bash



#ToDo
# Error -03
# Same file format




# Print usage 
usage(){
echo 'Usage: cut-video FILENAME(s)

Simple program that cuts a video file into a smaller segment. 

Running the first time creates a configuration file in $HOME/.config/ directory.

Exit statuses:
- 0 if cut is successful
- 1 if invalid filename is given
- 2 if aborted



This has been tested using vlc, but other video players should also work, perhaps with a modification of the code.
Please report any bugs at https://github.com/andis854/cut-video/issues.
If you want to contribute, please make a pull request to the dev branch on github.

Dependencies:
- ffmpeg
- ffprobe
- your video player
'
}



# Display error messages
echoerr () { echo "$@" 1>&2; }






# Check that configuration file exists
if [[ ! -e $HOME/.config/cut-video/config.conf || -z $( < $HOME/.config/cut-video/config.conf ) ]]; then
    mkdir -p $HOME/.config/cut-video
    read -p "Please choose a video player: " VIDEO_PLAYER
    echo $(whereis $VIDEO_PLAYER | awk '{print $2}') > $HOME/.config/cut-video/config.conf
fi










# Define necessary variables and arrays
VIDEO_PLAYER=$( < $HOME/.config/cut-video/config.conf )
[[ $VIDEO_PLAYER =~ vlc$ ]] && QUIT_PAR=vlc://quit # This is a vlc option only to quit the video automatically
VIDEO_FORMAT=.ts # $(echo $1 | grep -oE '\.[^.]+$')
TEMP_FILE="/tmp/cut-video-temp-file"
FILENAMES=()
underline=`tput smul`
nounderline=`tput rmul`
REGEX='([0-9]+\.[0-9]*|[1-9][0-9]*|[0-9]*\.[0-9]+)'



# Check existing files
for i in "${@}"; do
    [[ -e $i ]] && FILENAMES+=("$i")
done
# If no such files exist, print usage and exit 
[[ $FILENAMES =~ ^\ *$ ]] && usage && exit 1







#Iterate over valid files

COUNTER=0
for i in "${FILENAMES[@]}"; do
    echo $i
    DURATION=$(ffprobe -i "$i" -show_format 2>/dev/null | awk -F "=" '/duration/ { print $2 }')
    echo $DURATION
    COUNTER=$(($COUNTER+1))
    SATISFIED=n # Redo cut if n
    while [[ $SATISFIED == n ]]; do
        $VIDEO_PLAYER "$i" $QUIT_PAR 2>/dev/null &
        VLC_PID=$!
        echo -ne "\nStart at seconds [0]: "
        read START_VIDEO
        [[ ! $START_VIDEO =~ ^$REGEX$ ]] && START_VIDEO=0
        
        read -p "End at seconds [$DURATION]: " END_VIDEO
        [[ ! $END_VIDEO =~ ^$REGEX$ || $(python -c "print($START_VIDEO < $END_VIDEO)" ) != "True" ]] && END_VIDEO=$DURATION
            
        
        kill $VLC_PID 2>/dev/null
        
        echo $TEMP_FILE$COUNTER$VIDEO_FORMAT
        
        echo -e "${underline}\nChange start of video${nounderline}"
        while [[ $CHANGE_TIME != "r" ]]; do
            /usr/bin/ffmpeg -ss "$START_VIDEO" -to $(python -c "print($START_VIDEO+2)") -i "$i" -c copy -y $TEMP_FILE$COUNTER$VIDEO_FORMAT 2>/dev/null && $VIDEO_PLAYER $TEMP_FILE$COUNTER$VIDEO_FORMAT $QUIT_PAR 2>/dev/null &
            echo -ne "Start time is $START_VIDEO\nEnter new start time [s] or change it [\u00b1s]. Type 'r' when ready: "
            read CHANGE_TIME
            if [[ $CHANGE_TIME =~ ^$REGEX$ ]]; then
                START_VIDEO=$CHANGE_TIME
            elif [[ $CHANGE_TIME =~ ^[+-]$REGEX$ ]]; then
                START_VIDEO=$(python -c "print($START_VIDEO$CHANGE_TIME)")
            fi
        done    
        
        CHANGE_TIME=""
        
        echo -e "${underline}\nChange end of video${nounderline}"
        while [[ $CHANGE_TIME != "r" ]]; do
    
            /usr/bin/ffmpeg -ss $(python -c "print($END_VIDEO-2)") -to "$END_VIDEO" -i "$i" -c copy -y $TEMP_FILE$COUNTER$VIDEO_FORMAT 2>/dev/null && $VIDEO_PLAYER $TEMP_FILE$COUNTER$VIDEO_FORMAT $QUIT_PAR 2>/dev/null &
            
    
            echo -ne "End time is $END_VIDEO\nEnter new end time [s] or change it [\u00b1s]. Type 'r' when ready: "
            read CHANGE_TIME
    
    
    
            if [[ $CHANGE_TIME =~ ^$REGEX$ && $(python -c "print($START_VIDEO < $CHANGE_TIME )" ) == "True" ]]; then
                END_VIDEO=$CHANGE_TIME
            elif [[ $CHANGE_TIME =~ ^[+-]$REGEX$ && $(python -c "print($START_VIDEO < $END_VIDEO$CHANGE_TIME )" ) == "True" ]]; then
                END_VIDEO=$(python -c "print($END_VIDEO$CHANGE_TIME)")
            elif [[ $(python -c "print($START_VIDEO < $END_VIDEO)" ) != "True" ]]; then
                END_VIDEO=$DURATION
            fi
    
    
        done    
        
        
        /usr/bin/ffmpeg -ss "$START_VIDEO" -to "$END_VIDEO" -i "$i" -c copy -y $TEMP_FILE$COUNTER$VIDEO_FORMAT 2>/dev/null
        $VIDEO_PLAYER -R $TEMP_FILE$COUNTER$VIDEO_FORMAT $QUIT_PAR 2>/dev/null &
        VLC_PID=$!
        echo -ne "\n${underline}Your cut of '$i' is ready${nounderline}\nAre you satisfied with the video cut? [Y/n] "
        
        read SATISFIED
        kill $VLC_PID 2>/dev/null
        CHANGE_TIME=""
    done
done




# Suggested out filename
SUGG_FILENAME=$(echo $1 | sed -E 's/\.[^.]*$//')\ -\ cut-video$VIDEO_FORMAT 

echo -ne "\nOutput file [$SUGG_FILENAME]: "
read OUTPUT_FILE
[[ -z $OUTPUT_FILE ]] && OUTPUT_FILE=$SUGG_FILENAME
[[ ! $OUTPUT_FILE =~ "$VIDEO_FORMAT"$ ]] && OUTPUT_FILE=$OUTPUT_FILE$VIDEO_FORMAT 

[[ -e $OUTPUT_FILE ]] && echo ""
while [[ -e $OUTPUT_FILE && ! ( $OVERWRITE == y || $OVERWRITE == a ) ]]; do
    echo -ne "File '$OUTPUT_FILE' already exists. Overwrite? [(y)es/(a)bort/(c)hange] " && read OVERWRITE
    if [[ $OVERWRITE == c ]]; then
        echo -ne "\nOutput file [$SUGG_FILENAME]: "
        read OUTPUT_FILE
        [[ -z $OUTPUT_FILE ]] && OUTPUT_FILE=$SUGG_FILENAME
        [[ ! $OUTPUT_FILE =~ "$VIDEO_FORMAT"$ ]] && OUTPUT_FILE=$OUTPUT_FILE$VIDEO_FORMAT
    fi
done

rm "$TEMP_FILE-list.txt"
for ((i=1;i<=$COUNTER;i++)); do
    echo "file '$TEMP_FILE$i$VIDEO_FORMAT'" >> "$TEMP_FILE-list.txt"
done




# TEMP_FILES=()
# for ((i=1;i<=$COUNTER;i++)); do
#     $TEMP_FILE+=($TEMP_FILE$i$VIDEO_FORMAT)
# done
# 
# echo ${TEMP_FILES[@]}

[[ $OVERWRITE == y ]] && rm "$OUTPUT_FILE" && ffmpeg -f concat -safe 0 -i "$TEMP_FILE-list.txt" -c copy "$OUTPUT_FILE" 2>/dev/null && echo -e "\n'$OUTPUT_FILE' overwritten" && exit 0
[[ ! $OVERWRITE == a ]] && ffmpeg -f concat -safe 0 -i "$TEMP_FILE-list.txt" -c copy "$OUTPUT_FILE" 2>/dev/null && echo -e "\n'$OUTPUT_FILE' created" && exit 0
# [[ $OVERWRITE == y ]] && cat $TEMP_FILE > "$OUTPUT_FILE" && echo -e "\n$OUTPUT_FILE overwritten" && exit 0
# [[ ! $OVERWRITE == a ]] && cat $TEMP_FILE > "$OUTPUT_FILE" && echo -e "\n$OUTPUT_FILE created" && exit 0
[[ $OVERWRITE == a ]] && echoerr -e "\nAborted" && exit 2


